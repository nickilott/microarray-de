##############################################################################
#
#   MRC FGU CGAT
#
#   $Id$
#
#   Copyright (C) 2009 Andreas Heger
#
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License
#   as published by the Free Software Foundation; either version 2
#   of the License, or (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
###############################################################################
"""===========================
Pipeline kmeans
===========================

:Author: Nick Ilott
:Release: $Id$
:Date: |today|
:Tags: Python

Overview
========

Although this pipeline is called kmeans it also performs a PCA
analysis at the beginning which is somewhat redundant with other
pipelines but it allows a greater flexibility in the resulting
plots which is of interest when finalising figures etc.

Usage
=====

See :ref:`PipelineSettingUp` and :ref:`PipelineRunning` on general
information how to use CGAT pipelines.

Configuration
-------------

The pipeline requires a configured :file:`pipeline.ini` file.
CGATReport report requires a :file:`conf.py` and optionally a
:file:`cgatreport.ini` file (see :ref:`PipelineReporting`).

Default configuration files can be generated by executing:

   python <srcdir>/pipeline_kmeans.py config

Input files
-----------

None required except the pipeline configuration files.


Pipeline output
===============

.. Describe output files of the pipeline here

Glossary
========

.. glossary::


Code
====

"""
from ruffus import *

import sys
import os
import sqlite3
import CGAT.Experiment as E
import CGATPipelines.Pipeline as P
import CGAT.IOTools as IOTools
import collections

from rpy2.robjects import r as R

# load options from the config file
PARAMS = P.getParameters(
    ["%s/pipeline.ini" % os.path.splitext(__file__)[0],
     "../pipeline.ini",
     "pipeline.ini"])

########################################################
########################################################
########################################################


@follows(mkdir("kmeans.dir"))
@transform(PARAMS.get("input_matrix"),
           regex("(\S+)/(\S+).matrix"),
           add_inputs(PARAMS.get("input_diff_list")),
           r"kmeans.dir/\2.diff.matrix")
def buildDiffMatrix(infiles, outfile):
    '''
    subset the normalised data matrix for probes that
    arre differentially expressed
    '''
    mat, diff = infiles

    # build diff set
    diff = open(diff)
    diff.readline()
    diff_set = set([str(x.split("\t")[1])
                    for x in diff.readlines() if int(x.split("\t")[3]) !=0])

    # iterate over matrix and output those in diff list
    f = open(mat)
    header = f.readline()
    outf = open(outfile, "w")
    outf.write(header)

    found = set()
    for line in f.readlines():
        data = line[:-1].split("\t")

        # strip quotation marks
        id = data[-1].replace('"', "")
        if id in diff_set and id not in found:
            outf.write("\t".join(data) + "\n")
            found.add(id)
        else:
            continue
    outf.close()
    

########################################################
########################################################
########################################################


@follows(mkdir("kmeans.dir"))
@transform(buildDiffMatrix,
           suffix(".matrix"),
           ".kmeans")
def runKmeans(infile, outfile):
    '''
    run kmeans analysis
    '''
    # specify the number of clusters
    k = PARAMS.get("kmeans_k")

    R('''mat <- read.csv("%s",
                         header=T,
                         stringsAsFactors=F,
                         sep="\t")''' % infile)
    R('''rownames(mat) <- mat$ids''')
    R('''mat <- mat[,1:ncol(mat)-1]''')
    
    # scale rows before kmeans clustering
    R('''mat.s <- as.matrix(t(apply(mat, 1, scale)))''')
    R('''colnames(mat.s) <- colnames(mat)''')
    R('''mat.kmeans <- kmeans(mat.s, %i)''' % k)

    # write clusters
    R('''clusters <- mat.kmeans$cluster''')
    R('''clusters.df <- data.frame(cbind(names(clusters), unlist(clusters)))''')
    R('''colnames(clusters.df) <- c("probe", "cluster")''')
    R('''write.table(clusters.df, file="%s", row.names=F, sep="\t", quote=F)''' % outfile)

    
########################################################
########################################################
########################################################


@transform(buildDiffMatrix,
           suffix(".matrix"),
           add_inputs(runKmeans),
           ".heatmap.pdf")
def plotAnnotatedHeatmap(infiles, outfile):
    '''
    plot a heatmap with the clusters
    annotated
    '''
    mat, clusters = infiles

    R('''library(gplots)''')
    R('''library(gtools)''')
    R('''mat <- read.csv("%s",
                         header=T, 
                         stringsAsFactors=F,
                         sep="\t")''' % mat)

    R('''rownames(mat) <- mat$ids''')
    R('''mat <- mat[,1:ncol(mat)-1]''')
    
    R('''clusters <- read.csv("%s",
                              header=T,
                              stringsAsFactors=F,
                              sep="\t")''' % clusters) 

    # specify colours for annotations
    R('''ncolours <- max(clusters$cluster)''')
    R('''cols <- rainbow(ncolours, s=1, v=0.75)''')

    R('''ann.colours <- clusters$cluster''')

    # get matrix in same order
    R('''mat <- mat[as.character(clusters$probe),]''')

    R('''for (i in 1:length(ann.colours)){
             ann.colours[i] <- cols[as.numeric(ann.colours[i])]}''')

    # scale matrix
    R('''mat.s <- data.frame(t(apply(mat, 1, scale)))''')
    R('''colnames(mat.s) <- colnames(mat)''')

    
    R('''cols = colorRampPalette(c("blue", "white", "red"))(75)''')
    R('''pdf("%s", height = 10, width = 6)''' % outfile)
    R('''heatmap.2(as.matrix(mat.s), scale = "none", 
        hclustfun = function(x) hclust(x, method = "ward"), #
        distfun = function(x) dist(x, method = "manhattan")
        , trace = "none", col = cols, density.info = "none"
        , RowSideColors = ann.colours, margins = c(15,15), Colv = T)

    legend("topright",      
    legend = sort(unique(clusters$cluster)),
    col = rainbow(ncolours, s=1, v=0.75), 
    lty= 1,             
    lwd = 5,           
    cex=.7
    )

    dev.off()''')


########################################################
########################################################
########################################################
    

@follows(mkdir("pathways.dir"))
@split([runKmeans, PARAMS.get("input_probe2gene")],
       "pathways.dir/*.foreground")
def buildForegroundSets(infiles, outfile):
    '''
    build multiset of genes that are differentiallt
    expressed based on cluster assignments
    '''
    clusters, probe2gene_file = infiles

    # read probe 2 gene map
    probe2gene = {}
    probe2gene_file = IOTools.openFile(probe2gene_file)
    for line in probe2gene_file.readlines():
        data = line[:-1].split("\t")
        probe, gene = [x.replace('"', '') for x in data]
        probe2gene[probe] = gene
        
    # read probe 2 cluster map
    probe2cluster = {}
    clusters = IOTools.openFile(clusters)
    clusters.readline()
    for line in clusters.readlines():
        data = line[:-1].split("\t")
        probe, cluster = data
        probe2cluster[probe] = cluster
    
    # output genes in each cluster
    for c in set(probe2cluster.values()):
        outname = "pathways.dir/C%s.foreground" % c
        outf = IOTools.openFile(outname, "w")
        for probe, cluster in probe2cluster.iteritems():
            if cluster == c:
                outf.write("%s\n" % probe2gene[probe])
            else:
                continue
        outf.close()

########################################################
########################################################
########################################################


@follows(mkdir("pathways.dir"))
@merge([PARAMS.get("input_matrix"), PARAMS.get("input_probe2gene")],
       "pathways.dir/geneset.background")
def buildBackgroundGeneset(infiles, outfile):
    '''
    build background geneset i.e. all genes on the array
    that were expressed above background levels
    '''
    mat, probe2gene_file = infiles

    probe2gene_file = IOTools.openFile(probe2gene_file)
    probe2gene = {}
    for line in probe2gene_file:
        data = line[:-1].split("\t")
        probe, gene = data
        probe2gene[probe] = gene

    mat = IOTools.openFile(mat)
    mat.readline()
    outf = IOTools.openFile(outfile, "w")
    for line in mat.readlines():
        data = line[:-1].split("\t")
        probe = data[-1]
        outf.write("%s\n" % probe2gene[probe].replace('"', ''))
    outf.close()


########################################################
########################################################
########################################################


@transform(buildForegroundSets,
           suffix(".foreground"),
           add_inputs(buildBackgroundGeneset),
           ".results")
def runGO(infiles, outfile):
    '''
    run pathways analysis
    '''
    foreground, background, gene2pathway = infiles[0], infiles[1], PARAMS.get("pathways_geneset")
    c = P.snip(os.path.basename(foreground), ".foreground")
    threshold = PARAMS.get("pathways_threshold")
    
    statement = '''python %(cgatscriptsdir)s/runGO.py \
                   --genes=%(foreground)s \
                   --background=%(background)s \
                   --filename-input=%(gene2pathway)s \
                   -t %(threshold)s \
                   --sample-size=1000
                   --fdr \
                   --output-filename-pattern="pathways.dir/%(c)s.%%(section)s" \
                   > pathways.dir/pathways.log  
                '''
    P.run()


########################################################
########################################################
########################################################


@transform(runGO,
           suffix(".results"),
           add_inputs([runKmeans,
                       PARAMS.get("pathways_geneset"),
                       PARAMS.get("input_probe2gene")]),
           ".genes")
def getPathwayGenes(infiles, outfile):
    '''
    get genes that are asscociated with diff pathways
    '''
    pathway_file, clusters_file, geneset_file, probe2gene_file = [infiles[0]] + infiles[1]
    pathways = IOTools.openFile(pathway_file)

    # get which cluster it was
    cluster = os.path.basename(pathway_file)[1]
    
    # get genes associated with cluster
    probes = [x[:-1].split("\t")[0] for x in IOTools.openFile(clusters_file) if x[:-1].split("\t")[1] == cluster]
    
    # header
    pathways.readline()

    # get pathways
    sig_pathways = [x.split("\t")[11] for x in pathways.readlines()
                    if x.split("\t")[0] == "+"]

    # probe2gene map
    probe2gene_file = IOTools.openFile(probe2gene_file)
    probe2gene = {}
    for line in probe2gene_file:
        data = line[:-1].split("\t")
        probe, gene = data
        probe = probe.replace('"', '')
        gene = gene.replace('"', '')
        if probe in probes:
            probe2gene[probe] = gene
        else:
            continue

    # pathway2genes
    pathways_geneset = IOTools.openFile(geneset_file)
    pathway2genes = collections.defaultdict(set)
    for line in pathways_geneset.readlines():
        data = line[:-1].split("\t")
        pathway, gene = data[2], data[1]
        if pathway in sig_pathways:
            
            if gene in probe2gene.values():
                pathway2genes[pathway].add(gene)
            else:
                continue
        else:
            continue

    # output
    outf = open(outfile, "w")
    outf.write("pathway\tgene\n")
    for pathway, genes in pathway2genes.iteritems():
        for gene in genes:
            outf.write("%s\t%s\n" % (pathway, gene))
    outf.close()

    
########################################################
########################################################
########################################################


@follows(getPathwayGenes,plotAnnotatedHeatmap)
def full():
    pass


@follows(mkdir("report"))
def build_report():
    '''build report from scratch.

    Any existing report will be overwritten.
    '''

    E.info("starting report build process from scratch")
    P.run_report(clean=True)


@follows(mkdir("report"))
def update_report():
    '''update report.

    This will update a report with any changes inside the report
    document or code. Note that updates to the data will not cause
    relevant sections to be updated. Use the cgatreport-clean utility
    first.
    '''

    E.info("updating report")
    P.run_report(clean=False)


@follows(update_report)
def publish_report():
    '''publish report in the CGAT downloads directory.'''

    E.info("publishing report")
    P.publish_report()

if __name__ == "__main__":
    sys.exit(P.main(sys.argv))
